function SVN(){}

SVN.prototype.addFile=function(wcPath,isRecursive,externalHandler){
	var 
		events=[],		// array of event objects generated by this checkout
		file = new Myna.File(wcPath).javaFile, //java File object to represent the path
		WCClient,	// SVN WCClient
		x;				// generic loop counter
	if (isRecursive == undefined){
		isRecursive = true;	
	}
	
	WCClient = this.clientManager.getWCClient();
	var eventHandler = Packages.org.tmatesoft.svn.core.wc.ISVNEventHandler({
		handleEvent:function(event,progress){
			events.push(SVN.eventToObject(event,progress));
			if (externalHandler) externalHandler(event)
		}
	})
	
	WCClient.setEventHandler(eventHandler);
	WCClient.doAdd( file, false, false, true, isRecursive);
	return events;

}
SVN.prototype.connect=function(url,username,password){
	//var svnurl = java.lang.Class.forName('org.tmatesoft.svn.core.SVNURL').getMethod('parseURIDecoded',[java.lan.String]).invoke(null,[this.url]);
	//var svn = new Packages.org.tmatesoft.svn.core.SVNURL();
	this.url = url;
	this.username = username;
	this.password = password;
	Packages.org.tmatesoft.svn.core.internal.io.svn.SVNRepositoryFactoryImpl.setup();
	
	this.svnurl = Packages.org.tmatesoft.svn.core.SVNURL.parseURIDecoded(this.url);
	
	this.repository = Packages.org.tmatesoft.svn.core.io.SVNRepositoryFactory.create(this.svnurl);
	options = Packages.org.tmatesoft.svn.core.wc.SVNWCUtil.createDefaultOptions(true);
        
	/* Creates an instance of SVNClientManager providing authentication
	 * information (name, password) and an options driver
	 */
	
	auth = 	Packages.org.tmatesoft.svn.core.wc.SVNWCUtil.createDefaultAuthenticationManager(String(this.username),String(this.password));
	this.clientManager = Packages.org.tmatesoft.svn.core.wc.SVNClientManager.newInstance(options, auth);
	
	this.repository.setAuthenticationManager(auth);
	
	
	return this;
}
SVN.prototype.checkout=function(svnPath,wcPath,revision,progressCallback){
	var 
		rev,			// converted SVNRevision object
		events=[],		// array of event objects generated by this checkout
		file = new Myna.File(wcPath).javaFile, //java File object to represent the path
		updateClient,	// SVN updateClient
		url=this.svnurl.appendPath(svnPath,true), //path to folder to check out
		x;				// generic loop counter
	if (revision == undefined || revision == null){
		rev = Packages.org.tmatesoft.svn.core.wc.SVNRevision.HEAD;
	} else {
		rev = parseInt(revision);
		if (!isNaN(rev)){
			rev = Packages.org.tmatesoft.svn.core.wc.SVNRevision.create(revision);
		} else {
			throw "'" + rev +"' is not a valid revision number. Leave undefiend to get the HEAD revision.";
		}
	}
	
	/* if (! new java.io.File(wcPath).exists()){
		throw "Working Copy Path '" + wcPath + "' does not exist.";	
	} */
	
	
	updateClient = this.clientManager.getUpdateClient();
	var eventHandler = Packages.org.tmatesoft.svn.core.wc.ISVNEventHandler({
		handleEvent:function(event,progress){
			var eventObject = SVN.eventToObject(event,progress);
			events.push(eventObject);
			if (progressCallback) progressCallback(eventObject);
		}
	})
	
	updateClient.setEventHandler(eventHandler);
	updateClient.setIgnoreExternals(false);
	updateClient.doCheckout(url, file, rev, rev, true);
	return events;

}
SVN.prototype.commit_module=function(wcPath,message,isRecursive, externalHandler){
	var 
		events=[],		// array of event objects generated by this checkout
		file = new Myna.File(wcPath).javaFile, //java File object to represent the path
		commitClient,	// SVN commitClient
		x;				// generic loop counter
	if (isRecursive == undefined){
		isRecursive = true;	
	}
	if (message == undefined){
		message = "";	
	}

	//this.clientManager.getWCClient().doSetWCFormat(file, SVNAdminAreaFactory.WC_FORMAT_15);
	
	commitClient = this.clientManager.getCommitClient();
	
	var eventHandler = Packages.org.tmatesoft.svn.core.wc.ISVNEventHandler({
		handleEvent:function(event,progress){
			events.push(SVN.eventToObject(event,progress));
			if (externalHandler) externalHandler(event) 
		}
	})
	
	
	//do a quick cleanup. 
		this.clientManager.getWCClient().doCleanup(file);
	commitClient.doCommit([file], true, message, true, isRecursive);
	return events;

}
SVN.prototype.copy=function(svnSrc,svnDest,message,shouldOverwrite,isMove,revision){
	var 
		rev,			// converted SVNRevision object
		events=[],		// array of event objects generated by this checkout
		copyClient,	// SVN updateClient
		src=this.svnurl.appendPath(svnSrc,true), //path to folder to copy from
		dest=this.svnurl.appendPath(svnDest,true), //path to folder to copy to
		entries,
		keys,
		x;				// generic loop counter
	if (!revision){
		rev = Packages.org.tmatesoft.svn.core.wc.SVNRevision.HEAD;
	} else {
		rev = parseInt(revision);
		if (!isNaN(rev)){
			rev = Packages.org.tmatesoft.svn.core.wc.SVNRevision.create(revision);
		} else {
			throw "'" + rev +"' is not a valid revision number. Leave undefiend to get the HEAD revision.";
		}
	}
	if (!message){
		message = "";
	}
	if (isMove == undefined){
		isMove=false;
	}
	if (shouldOverwrite == undefined){
		shouldOverwrite=false;
	}
	
	if (this.pathExists(svnDest)){
		if (shouldOverwrite){
			this.deleteEntry(svnDest,"Path " + svnDest +" deleted for overwrite");
		} else {
			throw "Subversion path '" + svnDest + "' exists, and Overwrite was not indicated."
		}
	}
	
	copyClient = this.clientManager.getCopyClient();
	var eventHandler = Packages.org.tmatesoft.svn.core.wc.ISVNEventHandler({
		handleEvent:function(event,progress){
			events.push(SVN.eventToObject(event,progress));
		}
	})
	
	var sources, 
		dst, 
		isMove, 
		makeParents, 
		failWhenDstExists, 
		commitMessage, 
		revisionProperties
	
	copyClient.setEventHandler(eventHandler);
	copyClient.doCopy(
		[new org.tmatesoft.svn.core.wc.SVNCopySource(rev,rev,src)], 
		dest, 
		isMove, 
		true, 
		!shouldOverwrite, 
		message, 
		new org.tmatesoft.svn.core.SVNProperties()
		);
	return events;

}
SVN.prototype.deleteEntry=function(svnSrc,message){
	var 
		rev,			// converted SVNRevision object
		events=[],		// array of event objects generated by this checkout
		commitClient,	// SVN updateClient
		src=this.svnurl.appendPath(svnSrc,true), //path to folder to copy from
		x;				// generic loop counter
	
	if (!message){
		message = "Deleted entry: " + svnSrc;
	}
	
	
	commitClient = this.clientManager.getCommitClient();
	var eventHandler = Packages.org.tmatesoft.svn.core.wc.ISVNEventHandler({
		handleEvent:function(event,progress){
			events.push(SVN.eventToObject(event,progress));
		}
	})
	
	commitClient.setEventHandler(eventHandler);
	commitClient.doDelete([src],message);
	return events;

}
SVN.eventToObject=function(event,progress){
	return 	{
		action:String(event.getAction()),
		expectedAction:String(event.getExpectedAction()),
		contentsStatus:String(event.getContentsStatus()),
		errorMessage:String(event.getErrorMessage()),
		file:String(event.getFile()),
		mimeType:String(event.getMimeType()),
		nodeKind:String(event.getNodeKind()),
		wcPath:String(event.getFile()),
		getPropertiesStatus:String(event.getPropertiesStatus()),
		revision:String(event.getRevision()),
		progress:String(progress)
	}
}
SVN.prototype.export_module=function(svnPath,wcPath,revision,progressCallback){
	var 
		rev,			// converted SVNRevision object
		events=[],		// array of event objects generated by this checkout
		file = new Myna.File(wcPath).javaFile, //java File object to represent the path
		updateClient,	// SVN updateClient
		url=this.svnurl.appendPath(svnPath,true), //path to folder to check out
		x;				// generic loop counter
	if (revision == undefined || revision == null){
		rev = Packages.org.tmatesoft.svn.core.wc.SVNRevision.HEAD;
	} else {
		rev = parseInt(revision);
		if (!isNaN(rev)){
			rev = Packages.org.tmatesoft.svn.core.wc.SVNRevision.create(revision);
		} else {
			throw "'" + rev +"' is not a valid revision number. Leave undefined to get the HEAD revision.";
		}
	}
	
	/* if (! new java.io.File(wcPath).exists()){
		throw "Working Copy Path '" + wcPath + "' does not exist.";	
	} */
	
	//abort("svnpath",url);
	updateClient = this.clientManager.getUpdateClient();
	var eventHandler = Packages.org.tmatesoft.svn.core.wc.ISVNEventHandler({
		handleEvent:function(event,progress){
			var eventObject = SVN.eventToObject(event,progress)
			events.push(eventObject);
			if (progressCallback) progressCallback(eventObject);
		}
	})
	
	updateClient.setEventHandler(eventHandler);
	updateClient.setIgnoreExternals(false);
	updateClient.doExport(url, file, rev, rev, "native" ,true,true);
	return events;

}
SVN.prototype.getWcInfo=function(wcPath,isRecursive){
	var 
		infoEvents=[],		// array of event objects generated by this checkout
		file = new Myna.File(wcPath).javaFile, //java File object to represent the path
		commitClient,	// SVN commitClient
		x;				// generic loop counter
	if (isRecursive == undefined){
		isRecursive = true;	
	}
	
	
	WCClient = this.clientManager.getWCClient();
	var infoHandler = Packages.org.tmatesoft.svn.core.wc.ISVNInfoHandler({
		handleInfo:function(info){
			infoEvents.push(Myna.beanToObject(info));
		}
	})
	
	WCClient.doInfo(file, Packages.org.tmatesoft.svn.core.wc.SVNRevision.HEAD, isRecursive, infoHandler);
	return infoEvents;
}
SVN.prototype.getRepoEntries=function(path){
	var rawEntries=new java.util.ArrayList();
	var entries={}
	var properties = new org.tmatesoft.svn.core.SVNProperties()
	this.repository.getDir(path,new java.lang.Long(-1),properties,rawEntries)
	rawEntries=rawEntries.toArray();
	for (var i=0; i < rawEntries.length;++i){			
		var name =rawEntries[i].getName(); 
		entries[name] = {
			type:rawEntries[i].getKind().toString(),
			author:rawEntries[i].getAuthor(),
			last_updated:rawEntries[i].getDate(),
			revision:rawEntries[i].getRevision(),
			size:rawEntries[i].getSize()
		}
	}
	return entries;	
}
SVN.prototype.getLogEntries=function(svnPath){
	var 
		startRev =Packages.org.tmatesoft.svn.core.wc.SVNRevision.UNDEFINED,			// converted SVNRevision object
		endRev=Packages.org.tmatesoft.svn.core.wc.SVNRevision.UNDEFINED,
		logs=[],		// array of event objects generated by this checkout
		logClient,	// SVN updateClient
		url=this.svnurl.appendPath(svnPath,true), //path to folder to log
		x;				// generic loop counter
		
	logClient = this.clientManager.getLogClient();
	var logHandler = Packages.org.tmatesoft.svn.core.ISVNLogEntryHandler({
		handleLogEntry:function(logEntry){
			logs.push(Myna.beanToObject(logEntry));
		}
	})
	logClient.doLog(
		url,
		null,
		startRev,
		startRev,
		endRev,
		true,
		true,
		10000,
		logHandler
	);
  
	return logs;
}
SVN.prototype.importModule=function(wcPath,svnPath,message,isRecursive){
	var 
		events=[],		// array of event objects generated by this checkout
		file = new Myna.File(wcPath).javaFile, //java File object to represent the path
		CommitClient,	// SVN CommitClient
		url=this.svnurl.appendPath(svnPath,true), //path to folder to check out
		x;				// generic loop counter
	if (isRecursive == undefined){
		isRecursive = true;	
	}
	
	/* if (! new java.io.File(wcPath).exists()){
		throw "Working Copy Path '" + wcPath + "' does not exist.";	
	} */
	
	//abort("svnpath",url);
	CommitClient = this.clientManager.getCommitClient();
	var eventHandler = Packages.org.tmatesoft.svn.core.wc.ISVNEventHandler({
		handleEvent:function(event,progress){
			events.push(SVN.eventToObject(event,progress));
		}
	})
	
	CommitClient.setEventHandler(eventHandler);
	CommitClient.doImport( file, url, message, isRecursive);
	return events;

}

SVN.prototype.createRepoDirectory=function(svnPath){
	var 
		events=[],		// array of event objects generated by this checkout
		CommitClient,	// SVN CommitClient
		url=this.svnurl.appendPath(svnPath,true), //path to folder to check out
		x;				// generic loop counter
	
	CommitClient = this.clientManager.getCommitClient();
	var eventHandler = Packages.org.tmatesoft.svn.core.wc.ISVNEventHandler({
		handleEvent:function(event,progress){
			events.push(SVN.eventToObject(event,progress));
		}
	})
	
	CommitClient.setEventHandler(eventHandler);
	CommitClient.doMkDir( [url],"");
	return events;

}
SVN.prototype.pathExists=function(svnPath){
	try {
		 this.getRepoEntries(svnPath);
		 return true;
	}catch(e if e.javaException instanceof Packages.org.tmatesoft.svn.core.SVNException){}
	
	return false;
}
SVN.prototype.status=function(wcPath,externalHandler){
	var 
		statuses=[],		// array of event objects generated by this checkout
		file = new Myna.File(wcPath).javaFile, //java File object to represent the path
		statusClient,	// SVN statusClient
		x;				// generic loop counter

	
	statusClient = this.clientManager.getStatusClient();
	/* var eventHandler = Packages.org.tmatesoft.svn.core.wc.ISVNEventHandler({
		handleEvent:function(event,progress){
			events.push(SVN.eventToObject(event,progress));
		}
	}); */
	
	var statusHandler=Packages.org.tmatesoft.svn.core.wc.ISVNStatusHandler({
		handleStatus:function(status){
			statuses.push(beanToObject(status));
			if (externalHandler) externalHandler(status)
		}
	});
	//statusClient.setEventHandler(eventHandler);
	statusClient.doStatus(file, true, true, false, false, true, statusHandler);
	return statuses;

}
SVN.prototype.update_module=function(wcPath,revision,isRecursive, externalHandler){
	var 
		rev,			// converted SVNRevision object
		events=[],		// array of event objects generated by this checkout
		file = new Myna.File(wcPath).javaFile, //java File object to represent the path
		updateClient,	// SVN updateClient
		x;				// generic loop counter
	if (revision == undefined ){
		rev = Packages.org.tmatesoft.svn.core.wc.SVNRevision.HEAD;
	} else {
		rev = parseInt(revision);
		if (!isNaN(rev)){
			rev = Packages.org.tmatesoft.svn.core.wc.SVNRevision.create(revision);
		} else {
			throw "'" + rev +"' is not a valid revision number. Leave undefined to get the HEAD revision.";
		}
	}
	if (isRecursive == undefined){
		isRecursive = true;	
	}
	
	updateClient = this.clientManager.getUpdateClient();
	var options  = updateClient.getOptions();

	importPackage(Packages.org.tmatesoft.svn.core.wc);
	options.setConflictHandler(
		new ISVNConflictHandler({
			handleConflict:function (conflictDescription) {
				var mergeFiles = conflictDescription.getMergeFiles();
				return new SVNConflictResult(SVNConflictChoice.THEIRS_FULL,mergeFiles.getResultFile())
			}
		}
	));

	var eventHandler = new ISVNEventHandler({
		handleEvent:function(event,progress){
			events.push(SVN.eventToObject(event,progress));
			if (externalHandler) externalHandler(event)
		}
	})
	
	updateClient.setEventHandler(eventHandler);
	updateClient.setIgnoreExternals(false);
	
	Myna.println(file.exists())
	updateClient.doUpdate(file, rev, isRecursive);
	
	return events;

}